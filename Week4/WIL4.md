# WIL4

## **순차 지향 프로그래밍과 절차 지향 프로그래밍의 특징과 차이**

### 순차 지향 프로그래밍

‘순차적 프로그래밍’은 말 그대로 순차적으로 코드를 읽어내려가는 프로그래밍 구조를 의미한다.

즉, 순차(순서)를 중점으로 코드의 흐름에 따라 프로그래밍을 하기 때문에 코드의 구조가 따로 없고, goto문을 사용해서 코드를 짜야 하는 프로그래밍이라고 할 수 있다.

하지만, 코드의 규모가 커질수록 goto문이 많아진다면 프로그램 실행순서의 이동이 많아지면서 사람이 이해하기에 복잡해질 수 있는 문제점이 존재한다.

### 절차 지향 프로그래밍

'절차적 프로그래밍’을 영어로 번역하면 Procedural Programming인데, 여기서 말하는 Procedural는 순수하게 '절차적인'의 의미로 해석하는 것이 아니라 '프로시저', 즉 함수라는 뜻으로 쓰여진 것이다.

즉, 절차적 프로그래밍은 순차적인 명령 수행을 하는 순차 지향 프로그래밍과 다르게 루틴, 서브루틴, 메소드, 함수 등과 같은 프로시저를 이용해서 반복될 가능성이 있는 모듈을 재사용 가능하게 만든 프로그래밍이라고 할 수 있다.

따라서, goto문이 넘쳤던 순차적 프로그래밍의 문제점을 중복되는 부분은 for문이나 반복문과 같은 함수로 쪼개고 함수 호출을 통해서 해결하면서 추상화와 재사용성을 얻을 수 있다.

## **JVM의 역할과 가비지컬렉션(GC)이란?**

**자바 가상 머신**은 다양한 플랫폼(OS) 위에 설치되어 **자바 실행 파일을 실행 할 수 있도록 해주는 도구**로 ‘플랫폼 독립성’을 지니게 해준다.

<aside>
💡 **플랫폼 독립성 ?**                                                                                                                                   자바는 ‘**한번 작성하면 어느 플랫폼에서나 실행**’ (write once, run everywhere) 이 가능한 ‘**플랫폼 독립성**’을 특징으로 가지고 있다. 즉, **하나의 실행파일**(ex 자바실행파일 : .class)**이 모든 플랫폼** (ex 운영체제 : window / mac / liunx **)에서 실행이 가능**하다. **플랫폼 종속성**은 반대되는 개념으로 하나의 실행파일은 하나의 특정 플랫폼에서만 실행 할 수 있다고 생각하면 된다.

</aside>

즉,  Java 클래스 파일(.class)을 로드하고 소스파일(.java)은 컴파일러(javac)에 의해 중간단계 언어(바이트 코드)로 컴파일되고, 컴파일된 자바 클래스 파일(.class)을 OS에 맞는 기계어로 변환하여 실행시켜준다. 메모리 관리 측면에서 JVM은 메모리 구조를 만들고 main() 메소드가 실행되기 전에 전처리과정 수행 한다. 구체적으로는 java.lang 패키지,import된 패키지,모든 클래스들을 T메모리의 스태틱 영역에 가져다 놓는다.

### 가비지 컬렉션

가비지 컬렉션(Garbeage Collection)은 JVM에 탑재되어 있는 자바의 메모리 관리 기법으로, JVM의Heap 영역에서 동적으로 할당했던 메모리 영역 중 필요 없게 된 메모리 영역을 주기적으로 삭제해준다.

C나 C++에서는 가비지 컬렉션이 없기때문에 프로그래머가 수동으로 메모리 할당과 해제를 일일이 해줘야하지만 Java에서는 가비지 컬렉터가 메모리 관리를 대신해주기 때문에 프로그래머 입장에서 메모리 관리를 완벽하게 관리하지 않고 개발에만 집중할 수 있 장점이 있다.

단점으로는 메모리가 언제 해제되는지 정확하게 알 수 없고, 가비지 컬렉션이 동작하는 동안에는 다른 동작이 멈추기 때문에 오버헤드가 발생할 수도 있다는 점이 있다.

## **메소드, 힙, 스택 영역에 각각 어떤 게 존재하는지?**

**메소드 영역** : 메서드 인자(들)의 변수 공간

**힙 영역** : 객체와 객체 멤버 변수

**스택 영역** : 메소드들의 스택 프레임들 , 지역 변

## **“클래스는 붕어빵 틀이고 객체는 붕어빵이다.” 에 대해서 논하시오.**

클래스는 단지 객체를 생성하는데 사용될 뿐, 객체 그 자체는 아니며 원하는 기능을 위해서 객체가 필요하다. ( ex. 제품 설계도(클래스)와 제품(객체)과의 관계 )

클래스로부터 객체를 만드는 과정을 ‘클래스의 인스턴스화’라고 한다. 객체의 형식을 가지는 변수를 인스턴스라고 하고, 모든 인스턴스를 대표하는 포괄적인 의미를 가지는 것이 객체라고 해석 할 수 있다.

```jsx
사람 철수, 영희; //사람이라는 형식에 대한 인스턴스 = 철수, 영희
```

---

**<선택 정리 내용>**

[data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

1. 절차지향 프로그래밍은 객체지향 프로그래밍의 반대 개념이다. ( O / **X** )
2. 절차지향과 객체지향을 구분하는 방법으론 “상속, 다형성의 유무”가 있다. (**O** / X)
3. 다음 상황에 대해 답하시오.
    
    ```jsx
    Integer a = 500;
    Integer b = 500;
    ```
    
    (1) a와 b는 모두 스택 메모리 영역에 저장 공간을 확보한다. (O / **X**)
    
    (2) a.equals(b) 는 참이다. (**O** / X)
    
    (3) a == b 는 참이다. (O / **X**)
    
    ---
    
    <aside>
    💡 **equals**  **vs**  **==
    공통점** : 비교한 값을 boolean type으로 반
    
    **차이점** :  1. 형태의 차이  2. 비교할 수 있는 대상의 차이
    
    </aside>
    
    - 형태의 차이
        
        **equals()** : **메소드**, 객체끼리 내용 비교 가능
        
        **==** : **연산자**
        
    - 비교 대상 차이 ( 주소값 비교와 내용 비교 )
        
        **equals ()** 메소드 : 비교하고자하는 **대상의 내용 자체**를 비교
        
        **==** 연산자 : 비교하고자 하는 **대상의 주소값**을 비교
        

---

[data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

1. 객체지향 프로그래밍의 단점은 무엇인가? (성능과 설계 측면에서 각각 서술하시오.) 
    1. 처리속도가 절차지향보다 느리다.
    2. 설계에 많은 시간을 소요해야한다.    
    
2. 객체와 클래스의 차이는 무엇인가?
    
    **객체** : 실제로 존재하는 것, 사물 or 개념, 세상에 존재하는 유일무일한 사물
    
    변수(속성) 들과 그와 관련된 메서드(기능)들이 모여서 이룬 하나의 꾸러미
    
    **클래스** : C의 구조체에서 확정된 변수, 객체, 함수를 포함한 하나의 집합 / 분류, 집합, 같은 속성과 기능을 가진 객체를 총칭하는 개념
    

- 참고자료)
    
    [[프로그래밍 패러다임]순차적(비구조적),절차적(구조적),객체지향적 프로그래밍](https://kamang-it.tistory.com/3)
    
    [equals와 ==의 차이점](https://ojava.tistory.com/15)